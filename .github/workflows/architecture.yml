name: Architecture Validation

on:
  pull_request:
    branches: [ feature/v1-refactoring ]
    paths:
      - 'src/services/**/*.ts'
      - 'src/services/**/*.js'
      - 'src/**/*.ts'
      - 'src/**/*.js'
      - 'index.mjs'
      - 'package.json'

permissions:
  contents: read
  pull-requests: write

jobs:
  architecture:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v4

    - name: Use Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20.x'
        cache: 'npm'

    - name: Install dependencies
      run: |
        npm ci
        # Install architecture analysis tools
        npm list madge || npm install --save-dev madge@latest
        npm list dependency-cruiser || npm install --save-dev dependency-cruiser@latest

    - name: Analyze Service Architecture
      run: |
        set -euo pipefail
        echo "🏗️ Analyzing service architecture for node-grocy v1.0.0..."
        
        # Create architecture analysis script
        cat > analyze-architecture.mjs << 'EOF'
        import fs from 'fs';
        import path from 'path';
        
        function findServiceFiles() {
          const serviceFiles = [];
          const srcDir = 'src';
          
          if (!fs.existsSync(srcDir)) {
            console.log('No src directory found - analyzing monolithic structure');
            return ['index.mjs'];
          }
          
          function scanDirectory(dir) {
            const items = fs.readdirSync(dir, { withFileTypes: true });
            
            for (const item of items) {
              const fullPath = path.join(dir, item.name);
              
              if (item.isDirectory()) {
                scanDirectory(fullPath);
              } else if (item.name.endsWith('.ts') || item.name.endsWith('.js')) {
                serviceFiles.push(fullPath);
              }
            }
          }
          
          scanDirectory(srcDir);
          return serviceFiles;
        }
        
        function analyzeServiceBoundaries(files) {
          const services = {};
          const violations = [];
          
          files.forEach(file => {
            if (!fs.existsSync(file)) return;
            
            const content = fs.readFileSync(file, 'utf8');
            const fileName = path.basename(file, path.extname(file));
            
            // Extract service patterns
            const isService = fileName.toLowerCase().includes('service') || 
                            content.includes('class') && content.includes('Service');
            
            if (isService) {
              services[fileName] = {
                file,
                dependencies: extractDependencies(content),
                exports: extractExports(content),
                size: content.split('\n').length
              };
            }
            
            // Check for God objects (>500 lines)
            if (content.split('\n').length > 500) {
              violations.push({
                type: 'god_object',
                file,
                lines: content.split('\n').length,
                message: `File exceeds 500 lines (${content.split('\n').length})`
              });
            }
            
            // Check for circular dependencies (simplified)
            const imports = content.match(/import.*from\s+['"]([^'"]+)['"]/g) || [];
            const relativePaths = imports.filter(imp => imp.includes('./') || imp.includes('../'));
            
            if (relativePaths.length > 10) {
              violations.push({
                type: 'excessive_coupling',
                file,
                dependencies: relativePaths.length,
                message: `Too many local dependencies (${relativePaths.length})`
              });
            }
          });
          
          return { services, violations };
        }
        
        function extractDependencies(content) {
          const imports = content.match(/import.*from\s+['"]([^'"]+)['"]/g) || [];
          return imports.map(imp => imp.match(/from\s+['"]([^'"]+)['"]/)[1]);
        }
        
        function extractExports(content) {
          const exports = [];
          
          // Find class exports
          const classMatches = content.match(/export\s+class\s+(\w+)/g);
          if (classMatches) {
            exports.push(...classMatches.map(m => m.replace('export class ', '')));
          }
          
          // Find function exports
          const funcMatches = content.match(/export\s+(?:async\s+)?function\s+(\w+)/g);
          if (funcMatches) {
            exports.push(...funcMatches.map(m => m.replace(/export\s+(?:async\s+)?function\s+/, '')));
          }
          
          return exports;
        }
        
        const files = findServiceFiles();
        console.log(`Found ${files.length} files to analyze`);
        
        const analysis = analyzeServiceBoundaries(files);
        
        const results = {
          timestamp: new Date().toISOString(),
          filesAnalyzed: files.length,
          servicesFound: Object.keys(analysis.services).length,
          violations: analysis.violations,
          services: analysis.services,
          isMonolithic: files.length === 1 && files[0] === 'index.mjs'
        };
        
        fs.writeFileSync('architecture-analysis.json', JSON.stringify(results, null, 2));
        
        console.log('Architecture Analysis Results:');
        console.log(`- Files analyzed: ${results.filesAnalyzed}`);
        console.log(`- Services found: ${results.servicesFound}`);
        console.log(`- Violations: ${results.violations.length}`);
        console.log(`- Is monolithic: ${results.isMonolithic}`);
        
        if (results.violations.length > 0) {
          console.log('\nViolations found:');
          results.violations.forEach(v => {
            console.log(`  ${v.type}: ${v.file} - ${v.message}`);
          });
        }
        EOF
        
        node analyze-architecture.mjs

    - name: Check Dependency Injection Patterns
      run: |
        set -euo pipefail
        echo "💉 Checking dependency injection patterns..."
        
        cat > check-di.mjs << 'EOF'
        import fs from 'fs';
        
        function analyzeDI() {
          const results = {
            hasConstructorInjection: false,
            hasServiceInterfaces: false,
            hasFactoryPattern: false,
            violations: [],
            recommendations: []
          };
          
          // Check if we have TypeScript interfaces for DI
          const files = ['src', '.'].flatMap(dir => {
            if (!fs.existsSync(dir)) return [];
            return fs.readdirSync(dir, { recursive: true })
              .filter(f => (f.endsWith('.ts') || f.endsWith('.js') || f.endsWith('.mjs')))
              .map(f => dir === '.' ? f : `${dir}/${f}`);
          });
          
          files.forEach(file => {
            if (!fs.existsSync(file)) return;
            
            const content = fs.readFileSync(file, 'utf8');
            
            // Check for constructor injection
            if (content.includes('constructor(') && content.includes('private') || content.includes('public')) {
              results.hasConstructorInjection = true;
            }
            
            // Check for interfaces
            if (content.includes('interface I') || content.includes('interface') && content.includes('Service')) {
              results.hasServiceInterfaces = true;
            }
            
            // Check for factory pattern
            if (content.includes('Factory') || content.includes('create') && content.includes('Service')) {
              results.hasFactoryPattern = true;
            }
            
            // Check for direct instantiation (anti-pattern)
            const directNew = content.match(/new\s+\w+Service\(/g);
            if (directNew && directNew.length > 0) {
              results.violations.push({
                file,
                type: 'direct_instantiation',
                count: directNew.length,
                message: `Direct service instantiation found (${directNew.length} instances)`
              });
            }
            
            // Check for singleton pattern issues
            if (content.includes('getInstance') && !content.includes('private constructor')) {
              results.violations.push({
                file,
                type: 'singleton_pattern',
                message: 'Singleton pattern detected - consider DI instead'
              });
            }
          });
          
          // Generate recommendations
          if (!results.hasConstructorInjection) {
            results.recommendations.push('Implement constructor injection for services');
          }
          
          if (!results.hasServiceInterfaces) {
            results.recommendations.push('Create interfaces for service contracts');
          }
          
          if (!results.hasFactoryPattern && files.length > 5) {
            results.recommendations.push('Consider factory pattern for service creation');
          }
          
          return results;
        }
        
        const diAnalysis = analyzeDI();
        fs.writeFileSync('di-analysis.json', JSON.stringify(diAnalysis, null, 2));
        
        console.log('Dependency Injection Analysis:');
        console.log(`- Constructor injection: ${diAnalysis.hasConstructorInjection ? '✅' : '❌'}`);
        console.log(`- Service interfaces: ${diAnalysis.hasServiceInterfaces ? '✅' : '❌'}`);
        console.log(`- Factory pattern: ${diAnalysis.hasFactoryPattern ? '✅' : '❌'}`);
        console.log(`- Violations: ${diAnalysis.violations.length}`);
        
        if (diAnalysis.violations.length > 0) {
          console.log('\nDI Violations:');
          diAnalysis.violations.forEach(v => console.log(`  ${v.type}: ${v.message}`));
        }
        
        if (diAnalysis.recommendations.length > 0) {
          console.log('\nRecommendations:');
          diAnalysis.recommendations.forEach(r => console.log(`  - ${r}`));
        }
        EOF
        
        node check-di.mjs

    - name: Detect Circular Dependencies
      run: |
        set -euo pipefail
        echo "🔄 Checking for circular dependencies..."
        
        # Use madge if available, otherwise simple check
        if npx madge --version > /dev/null 2>&1; then
          echo "Using madge for dependency analysis..."
          npx madge --circular --format json . > circular-deps.json 2>/dev/null || echo "[]" > circular-deps.json
          
          CIRCULAR_COUNT=$(cat circular-deps.json | jq '. | length' 2>/dev/null || echo "0")
          
          if [ "$CIRCULAR_COUNT" -gt 0 ]; then
            echo "❌ Circular dependencies detected: $CIRCULAR_COUNT"
            echo "CIRCULAR_DEPENDENCIES=true" >> $GITHUB_ENV
            echo "CIRCULAR_COUNT=$CIRCULAR_COUNT" >> $GITHUB_ENV
          else
            echo "✅ No circular dependencies found"
            echo "CIRCULAR_DEPENDENCIES=false" >> $GITHUB_ENV
            echo "CIRCULAR_COUNT=0" >> $GITHUB_ENV
          fi
        else
          echo "Madge not available, skipping circular dependency check"
          echo "CIRCULAR_DEPENDENCIES=false" >> $GITHUB_ENV
          echo "CIRCULAR_COUNT=0" >> $GITHUB_ENV
        fi

    - name: Validate Service Boundaries
      run: |
        set -euo pipefail
        echo "🏭 Validating service boundaries..."
        
        cat > validate-boundaries.mjs << 'EOF'
        import fs from 'fs';
        
        function validateBoundaries() {
          let analysis;
          try {
            analysis = JSON.parse(fs.readFileSync('architecture-analysis.json', 'utf8'));
          } catch (e) {
            console.log('No architecture analysis found');
            return { valid: true, violations: [] };
          }
          
          const violations = [];
          
          // Check for monolithic structure
          if (analysis.isMonolithic) {
            violations.push({
              type: 'monolithic_structure',
              severity: 'warning',
              message: 'Codebase is still monolithic - consider service extraction'
            });
          }
          
          // Check service sizes
          Object.entries(analysis.services || {}).forEach(([name, service]) => {
            if (service.size > 300) {
              violations.push({
                type: 'large_service',
                severity: 'warning',
                service: name,
                size: service.size,
                message: `Service ${name} is large (${service.size} lines) - consider splitting`
              });
            }
            
            if (service.dependencies && service.dependencies.length > 8) {
              violations.push({
                type: 'high_coupling',
                severity: 'error',
                service: name,
                dependencies: service.dependencies.length,
                message: `Service ${name} has too many dependencies (${service.dependencies.length})`
              });
            }
          });
          
          const result = {
            valid: violations.filter(v => v.severity === 'error').length === 0,
            violations,
            summary: {
              errors: violations.filter(v => v.severity === 'error').length,
              warnings: violations.filter(v => v.severity === 'warning').length
            }
          };
          
          fs.writeFileSync('boundary-validation.json', JSON.stringify(result, null, 2));
          return result;
        }
        
        const validation = validateBoundaries();
        
        console.log('Service Boundary Validation:');
        console.log(`- Errors: ${validation.summary.errors}`);
        console.log(`- Warnings: ${validation.summary.warnings}`);
        console.log(`- Overall: ${validation.valid ? '✅ VALID' : '❌ INVALID'}`);
        
        if (validation.violations.length > 0) {
          console.log('\nViolations:');
          validation.violations.forEach(v => {
            console.log(`  ${v.severity.toUpperCase()}: ${v.message}`);
          });
        }
        
        if (!validation.valid) {
          process.exit(1);
        }
        EOF
        
        node validate-boundaries.mjs

    - name: Generate Architecture Report
      run: |
        echo "📋 Generating comprehensive architecture report..."
        
        cat > architecture-report.md << 'EOF'
        # Architecture Validation Report
        
        Generated on: $(date)
        PR: #${{ github.event.pull_request.number }}
        
        ## Executive Summary
        
        EOF
        
        # Add analysis results using jq
        echo "| Metric | Status |" >> architecture-report.md
        echo "|--------|--------|" >> architecture-report.md
        
        # Architecture type
        IS_MONOLITHIC=$(jq -r '.isMonolithic // true' architecture-analysis.json 2>/dev/null)
        if [ "$IS_MONOLITHIC" = "true" ]; then
          echo "| **Architecture Type** | 🏗️ Monolithic |" >> architecture-report.md
        else
          echo "| **Architecture Type** | 🏭 Modular |" >> architecture-report.md
        fi
        
        echo "| **Services Found** | $(jq '.servicesFound // 0' architecture-analysis.json 2>/dev/null || echo 0) |" >> architecture-report.md
        echo "| **Files Analyzed** | $(jq '.filesAnalyzed // 0' architecture-analysis.json 2>/dev/null || echo 0) |" >> architecture-report.md
        echo "| **Circular Dependencies** | ${{ env.CIRCULAR_COUNT }} |" >> architecture-report.md
        
        # DI Pattern
        HAS_DI=$(jq -r '.hasConstructorInjection // false' di-analysis.json 2>/dev/null)
        if [ "$HAS_DI" = "true" ]; then
          echo "| **DI Pattern** | ✅ Implemented |" >> architecture-report.md
        else
          echo "| **DI Pattern** | ❌ Missing |" >> architecture-report.md
        fi
        
        # Service Interfaces
        HAS_INTERFACES=$(jq -r '.hasServiceInterfaces // false' di-analysis.json 2>/dev/null)
        if [ "$HAS_INTERFACES" = "true" ]; then
          echo "| **Service Interfaces** | ✅ Present |" >> architecture-report.md
        else
          echo "| **Service Interfaces** | ❌ Missing |" >> architecture-report.md
        fi
        
        # Boundary Violations
        ERRORS=$(jq '.summary.errors // 0' boundary-validation.json 2>/dev/null || echo 0)
        WARNINGS=$(jq '.summary.warnings // 0' boundary-validation.json 2>/dev/null || echo 0)
        TOTAL_VIOLATIONS=$((ERRORS + WARNINGS))
        echo "| **Boundary Violations** | $TOTAL_VIOLATIONS |" >> architecture-report.md
        
        echo "" >> architecture-report.md
        echo "## Detailed Analysis" >> architecture-report.md
        echo "" >> architecture-report.md
        
        # Add monolithic guidance if applicable
        IS_MONOLITHIC=$(jq -r '.isMonolithic // true' architecture-analysis.json 2>/dev/null)
        
        if [ "$IS_MONOLITHIC" = "true" ]; then
          echo "### 🏗️ Monolithic Structure Detected" >> architecture-report.md
          echo "" >> architecture-report.md
          echo "The codebase is currently monolithic. For v1.0.0 refactoring, consider:" >> architecture-report.md
          echo "" >> architecture-report.md
          echo "1. **Extract Stock Service** - Handle inventory operations" >> architecture-report.md
          echo "2. **Extract Shopping List Service** - Manage shopping lists" >> architecture-report.md
          echo "3. **Extract Recipe Service** - Recipe and meal planning" >> architecture-report.md
          echo "4. **Extract User Service** - Authentication and user management" >> architecture-report.md
          echo "5. **Create Base Service** - Common HTTP operations" >> architecture-report.md
          echo "" >> architecture-report.md
        fi
        
        # Add DI recommendations
        echo "### 💉 Dependency Injection Recommendations" >> architecture-report.md
        echo "" >> architecture-report.md
        
        HAS_DI=$(jq -r '.hasConstructorInjection // false' di-analysis.json 2>/dev/null)
        
        if [ "$HAS_DI" = "false" ]; then
          echo "⚠️ **No dependency injection detected.** For v1.0.0:" >> architecture-report.md
          echo "" >> architecture-report.md
          echo "\`\`\`typescript" >> architecture-report.md
          echo "// Recommended DI pattern" >> architecture-report.md
          echo "interface IHttpClient {" >> architecture-report.md
          echo "  get(url: string): Promise<Response>;" >> architecture-report.md
          echo "}" >> architecture-report.md
          echo "" >> architecture-report.md
          echo "class StockService {" >> architecture-report.md
          echo "  constructor(private httpClient: IHttpClient) {}" >> architecture-report.md
          echo "}" >> architecture-report.md
          echo "\`\`\`" >> architecture-report.md
        else
          echo "✅ **Dependency injection patterns detected**" >> architecture-report.md
        fi
        
        echo "" >> architecture-report.md
        echo "## Next Steps for v1.0.0 Refactoring" >> architecture-report.md
        echo "" >> architecture-report.md
        echo "1. 🏗️ **Service Extraction**: Break monolith into domain services" >> architecture-report.md
        echo "2. 💉 **Implement DI**: Add constructor injection and interfaces" >> architecture-report.md
        echo "3. 🔄 **Eliminate Cycles**: Remove circular dependencies" >> architecture-report.md
        echo "4. 📏 **Size Management**: Keep services under 300 lines" >> architecture-report.md
        echo "5. 🧪 **Testing Strategy**: Unit test each service independently" >> architecture-report.md

    - name: Check Architecture Violations
      run: |
        set -euo pipefail
        # Fail if there are critical architecture violations
        ERRORS=$(jq '.summary.errors // 0' boundary-validation.json 2>/dev/null || echo 0)
        
        CIRCULAR_DEPS="${{ env.CIRCULAR_DEPENDENCIES }}"
        
        if [ "$ERRORS" -gt 0 ] || [ "$CIRCULAR_DEPS" = "true" ]; then
          echo "❌ CRITICAL ARCHITECTURE VIOLATIONS DETECTED"
          echo ""
          if [ "$ERRORS" -gt 0 ]; then
            echo "Boundary violations: $ERRORS"
          fi
          if [ "$CIRCULAR_DEPS" = "true" ]; then
            echo "Circular dependencies: ${{ env.CIRCULAR_COUNT }}"
          fi
          echo ""
          echo "Fix these issues before merging to maintain code quality."
          exit 1
        fi
        
        echo "✅ Architecture validation passed"

    - name: Upload Architecture Reports
      uses: actions/upload-artifact@v4
      with:
        name: architecture-reports
        path: |
          architecture-report.md
          architecture-analysis.json
          di-analysis.json
          boundary-validation.json
          circular-deps.json
        retention-days: 30

    - name: Comment on PR
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          
          let comment = `## 🏗️ Architecture Validation\n\n`;
          
          // Read analysis results
          let archAnalysis = {};
          try {
            archAnalysis = JSON.parse(fs.readFileSync('architecture-analysis.json', 'utf8'));
          } catch (e) {}
          
          let diAnalysis = {};
          try {
            diAnalysis = JSON.parse(fs.readFileSync('di-analysis.json', 'utf8'));
          } catch (e) {}
          
          const circularDeps = '${{ env.CIRCULAR_DEPENDENCIES }}' === 'true';
          const circularCount = '${{ env.CIRCULAR_COUNT }}' || 0;
          
          // Add summary table
          comment += `| Metric | Status |\n`;
          comment += `|--------|--------|\n`;
          comment += `| Architecture | ${archAnalysis.isMonolithic ? '🏗️ Monolithic' : '🏭 Modular'} |\n`;
          comment += `| Services | ${archAnalysis.servicesFound || 0} |\n`;
          comment += `| DI Pattern | ${diAnalysis.hasConstructorInjection ? '✅' : '❌'} |\n`;
          comment += `| Circular Deps | ${circularDeps ? `❌ ${circularCount}` : '✅ None'} |\n\n`;
          
          // Add monolithic guidance
          if (archAnalysis.isMonolithic) {
            comment += `### 🏗️ Monolithic Structure\n`;
            comment += `This codebase is currently monolithic. For v1.0.0 refactoring:\n`;
            comment += `- Extract domain services (Stock, Shopping, Recipe, User)\n`;
            comment += `- Implement dependency injection patterns\n`;
            comment += `- Create service interfaces for better testability\n\n`;
          }
          
          // Add DI recommendations
          if (!diAnalysis.hasConstructorInjection) {
            comment += `### 💉 Dependency Injection Needed\n`;
            comment += `Consider implementing constructor injection for better modularity.\n\n`;
          }
          
          comment += `📊 [View detailed architecture report](${context.payload.pull_request.html_url}/checks)\n\n`;
          comment += `---\n`;
          comment += `*This comment was automatically generated by the Architecture Validation workflow*`;
          
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: comment
          });

    - name: Cache Architecture Data
      uses: actions/cache@v4
      with:
        path: |
          architecture-analysis.json
          di-analysis.json
        key: architecture-${{ runner.os }}-${{ github.sha }}
        restore-keys: |
          architecture-${{ runner.os }}-
